import os
from pdfrw import PdfReader, PdfWriter, PdfDict, PdfName, PdfObject, PageMerge
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from io import BytesIO
from pypdf import PdfReader as PyPdfReader

# Helper: extract fields and types using pypdf for robust detection,
# and annotate with original pdfrw objects when needed.
def extract_fields(path):
    reader = PyPdfReader(path)
    fields = {}
    try:
        # get_form_text_fields returns text fields; but we iterate annotations for types
        for page in reader.pages:
            if "/Annots" in page:
                annots = page["/Annots"]
                for a in annots:
                    obj = a.get_object()
                    name = obj.get("/T")
                    if not name:
                        continue
                    name = name.strip('()')
                    ft = obj.get("/FT")  # field type
                    if ft:
                        ft = ft.name  # e.g. '/Tx' -> 'Tx' ? sometimes it's PdfName. We'll normalize.
                    # Normalize
                    raw_ft = obj.get("/FT")
                    if raw_ft:
                        ft_name = raw_ft.__str__()
                    else:
                        ft_name = None
                    # Determine type: text (Tx), button (Btn) - checkbox/radio, choice (Ch)
                    if ft_name and '/Btn' in ft_name:
                        # Determine if checkbox or radio by /Kids and /AS or /Opt
                        # We'll mark as 'button' and try to find export values below
                        fields[name] = { 'type': 'button', 'value': '' }
                    elif ft_name and '/Tx' in ft_name:
                        fields[name] = { 'type': 'text', 'value': '' }
                    elif ft_name and '/Ch' in ft_name:
                        fields[name] = { 'type': 'choice', 'value': '' }
                    else:
                        fields[name] = { 'type': 'unknown', 'value': '' }
    except Exception:
        # fallback to simple method
        try:
            ff = reader.get_form_text_fields()
            for k, v in ff.items():
                fields[k] = { 'type': 'text', 'value': v or '' }
        except Exception:
            pass
    return fields

# Use pdfrw to write values including checkboxes/radios.
def fill_pdf(input_path, output_path, data: dict, flatten=True):
    """Fill form fields in a PDF using pdfrw. data is a dict {fieldname: value}.
       For checkboxes/radios provide the export value exactly as present in the PDF (e.g. 'Yes').
    """
    pdf = PdfReader(input_path)
    ANNOT_KEY = '/Annots'
    SUBTYPE_KEY = '/Subtype'
    WIDGET_SUBTYPE = '/Widget'

    for page in pdf.pages:
        annotations = page.get(ANNOT_KEY)
        if not annotations:
            continue
        for annot in annotations:
            if annot.get(SUBTYPE_KEY) != WIDGET_SUBTYPE:
                continue
            t = annot.get('/T')
            if not t:
                continue
            name = t.to_unicode().strip('()')
            if name not in data:
                continue
            value = data.get(name)
            # Field type
            ftype = annot.get('/FT')
            # Text field
            if ftype == PdfName('Tx') or (ftype and 'Tx' in ftype.__str__()):
                # Set the V key to string
                annot.update(PdfDict(V='{}'.format(value)))
                # Also set the AP (appearance) will be regenerated by flatten step.
            elif ftype == PdfName('Btn') or (ftype and 'Btn' in ftype.__str__()):
                # Button: could be checkbox or radio. We set /V and /AS to the export value name.
                # Common export values are names like '/Yes'. We try to set to the provided value.
                # If user provided "on" or "yes" we'll try to map to a name; otherwise set raw.
                export = value
                if isinstance(export, bool):
                    export = 'Yes' if export else 'Off'
                elif export in ('on','yes','true','1'):
                    export = 'Yes'
                elif export in ('off','no','false','0', ''):
                    export = 'Off'
                # Wrap as PdfName
                try:
                    annot.update(PdfDict(V=PdfName(export), AS=PdfName(export)))
                except Exception:
                    # fallback: set string value
                    annot.update(PdfDict(V='{}'.format(export)))
            elif ftype == PdfName('Ch') or (ftype and 'Ch' in ftype.__str__()):
                # Choice field (dropdown)
                annot.update(PdfDict(V='{}'.format(value)))
            else:
                # unknown type - try to set V
                annot.update(PdfDict(V='{}'.format(value)))

    if flatten:
        # Remove annotations (widgets) so file becomes static.
        for page in pdf.pages:
            if page.Annots:
                page.Annots = []
        # Also clear AcroForm to avoid re-editing
        if pdf.Root and pdf.Root.AcroForm:
            pdf.Root.AcroForm = None

    writer = PdfWriter()
    writer.write(output_path, pdf)
    return output_path
